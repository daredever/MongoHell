## Welcome part

*Дима:*

Добрый день, друзья, рады приветствовать Вас на 58 встрече Петербургского .net сообщества, проходящей в коллаборации с Центром Речевых Технологий. 
Меня зовут Елисеев Дмитрий, я занимаюсь базами данных в ЦРТ. 

*Рома:*

Меня зовут Роман Щербаков, и я занимаюсь разработкой бэк-енда в ЦРТ и мы хотели бы рассказать Вам о внедрении MongoDB в .net проект. 

*Дима:*

Рассказ об обследовании проекта.
И так, почему же MongoDB? Придя на новый проект, я начал анализировать чем он живёт, какие перспективы, какие технологии используются.
Одной из первых задач которая мне прилетела была - тормозит postgtres.
Углубившись в суть проблемы, я обнаружил, что тормозит поиск по json документу,
Имея за спиной понимание, что для таких целеЙ гораздо лучше подходит Mongo, я решился на попытку её внедрения 
И именно в этот момент начинается "Божественная комедия" внедрения MongoDB в .net проект.

Раскрыть тему с хранением в монге для новичков (база, коллекция, документ, BSON, _id).
Сравнение хранения pg vs mongodb. 

Раскрыть тему кругов (тут слайд с картинкой данте).

#  Circles of Hell

## 1 круг - Лимб. 

*Дима:*

- Предложение внедрить монгу. 
Когда я подошёл к архитектору нашего проекта с вопросом, а почему собственно не Mongo? 
Я услышал стандартные ответы:
- она не стабильна, у нас был опыт использования, но он оказался неудачным в 2013 году
- течёт память (режим standalone, не было человека который мог поднять кластер, 
поддержка монги сказала нужен кластер)
- ошибки на бою database corrupted и не восстанавливалась
- нет транзакций

Железобетонные аргументы, через которые казалось бы не пробиться.
Однако, понимая что постгрес не даст таких же показателей перформанса как Mongo,
я решил обратиться к ресёрчу который проводился к 51 встрече, и на примере документов с ссылкой
и документа в документе показал, что по производительности mongoDB выигрывает у пг.

Бенчмарки производительности для любого руководства  всегда выглядят весомо.
Информация о лицензировании.
 
Простота репликации и шардирования, не требующая глубокого понимания принципов работы БД. 
Самое главное отказоусточивость - **КЛАСТЕР**!

Отсутствие жёсткой схемы данных(если надо, то можно настроить), если Вы работаете с динамически изменяемой структурой объекта, это то, что Вам нужно. 

Ну и естественно бесплатность использования.

Показав все достоинства, и когда они взяты во внимание, мы переходим ко второму кругу

_Вывод - у монги много плюсов._

## 2 круг - Сладострастие.

*Дима:* 

Проанализировав проект, и поняв что большинство сервисов хранит jobject в пг,
и воодушевившись показателями синтетик тестов сразу чешутся руки творить добро и справедливость,
и воткнуть монго везде, но эта эйфория обманчива
Если есть сервис аутентификации, и его работа с ролями, пользователями и сессиями вполне себе реляционна, и работает он стабильно и быстро, то трудозатраты по переезду на монгу явно не окупятся профитом.
Но если говорить об остальных сервисах, то часть разработчиков как всегда занята допиливанием фич,
часть на баг-фиксинге. Естественно выцепить ресурсы у руководства под рефакторинг довольно сложно.
Нужна была такая подсистема, которая не заденет ядро системы, и  тем не менее сможет показать профит от технологии
В нашем случае выбор пал на импорт из внешних систем и вот почему
- Данные могут приходить в каком угодно формате
- Схема данных заранее неизвестна
- Необходима высокая скорость записи и чтения

Когда мною был продуман принцип работы сервиса внешней интеграции, получено разрешение архитектора творить под мою ответственность, я пришёл к Роме, и тут начался третий круг

_Вывод - начать с малого._

## 3 круг - Чревоугодие.  (live coding)

*Рома:*

- Реализация стандартного  ETL процесса: source - mongodb - destination. 
Рассказать этапы импорта из черного ящика (get from source, check if exists in db, insert or update to destination, update db).
Описать суть проблемы. Описать решение на PG. 
Показать структуру таблиц, рассказать о генерации схемы данных. 
Показать зачем нужна монга.   

Дальше показываем как сделать простейший импорт (предаствим что у нас некая CRM для ада):

- Показываем что ПГ поднят и там есть данные. Показываем репозиторий ПГ для чтения записей.
Методы - получить список кругов ада, получить список монстров, получить список жителей ада. 

- Поднимаем stadlalone. Поясняем Connection string.
Строка подключения имеет следующий вид: mongodb://[username:password@]hostname[:port][/[database][?options]]

- Простота использования (Пример репозитория CRUD). 

Качаем nuget пакет MongoDB.Driver 

```c#
public interface IMongoModel
{
    string ExternalId { get; set; }
}

public class SimpleRepository<T> : ISimpleRepository<T> where T : IMongoModel
{
    private readonly IMongoDatabase _mongoDatabase;

    public SimpleRepository(string connectionString, string databaseName)
    {
        var client = new MongoClient(connectionString);
        _mongoDatabase = client.GetDatabase(databaseName);
    }

    public Task AddOrUpdateItemAsync(T item, string collectionName)
    {
        var keyCollection = _mongoDatabase.GetCollection<T>(collectionName);
        var options = new ReplaceOptions {IsUpsert = true};

        return keyCollection.ReplaceOneAsync(x => x.ExternalId == item.ExternalId, item, options);
    }

    public async Task<T> GetItemAsync(string id, string collectionName)
    {
        var keyCollection = _mongoDatabase.GetCollection<T>(collectionName);
        using var cursor = await keyCollection.FindAsync(x => x.ExternalId == id);
        return await cursor.SingleOrDefaultAsync();
    }

    public Task DeleteItemAsync(string id, string collectionName)
    {
        var keyCollection = _mongoDatabase.GetCollection<T>(collectionName);
        return keyCollection.DeleteOneAsync(x => x.ExternalId == id);
    }
}
```

После выполнения всех необходимых операций нам необязательно закрывать подключение, 
как, например, в случае с подключениями к другим базам данных, 
так как MongoDB сама выполнит всю работу (найти инфу в документации).

Добавили профилирование в код, чтобы понимать где конкретно происходят тормоза.

```c#
public sealed class Profiler : IDisposable
{
    public Profiler(string stage)
    {
        _stage = stage;
        _stopWatch = Stopwatch.StartNew();
    }

    public void Dispose()
    {
        _stopWatch.Stop();
        
        var workTime = Math.Round(_stopWatch.ElapsedTicks * MillisecPerTick, 4);
        // write data with _stage and workTime in milliseconds
        Console.WriteLine($"{_stage}, {workTime}");
    }

    public static Profiler GetProfiler(string stage) => new Profiler(stage);

    private static readonly decimal MillisecPerTick = 1000m / Stopwatch.Frequency;

    private readonly Stopwatch _stopWatch;
    private readonly string _stage;
}
```

Показать декоратор с подключенным профилированием:
```c#
public class SimpleRepositoryWithProfiling<T> : SimpleRepository<T> where T : IMongoModel
{
    public SimpleRepositoryWithProfiling(string connectionString, string databaseName) 
        : base(connectionString, databaseName)
    {
    }

    public override Task AddOrUpdateItemAsync(T item, string collectionName)
    {
        using var profiler = Profiler.GetProfiler(nameof(SimpleRepository<T>.AddOrUpdateItemAsync));
        return base.AddOrUpdateItemAsync(item, collectionName);
    }

    public override Task<T> GetItemAsync(string id, string collectionName)
    {
        using var profiler = Profiler.GetProfiler(nameof(SimpleRepository<T>.GetItemAsync));
        return base.GetItemAsync(id, collectionName);
    }

    public override Task DeleteItemAsync(string id, string collectionName)
    {
        using var profiler = Profiler.GetProfiler(nameof(SimpleRepository<T>.DeleteItemAsync));
        return base.DeleteItemAsync(id, collectionName);
    }
}
```

- Проливаем данные из PG. Показать результаты профилирования в консоль.
- Показываем что схемы не было и автоматически создались база и коллекции. 
Можно повторить N раз меняя имя базы и коллекции.
показываем что для ПГ надо было постоянно контролировать схему и миграции.
- Перфоманс из коробки - показываем график из данных профилирования (все быстро и хорошо).

_Вывод - все просто. Начать работать с монгой легко._

## 4 круг - Жадность.

*Дима:*

Глядя на результат, как красиво у нас бегут и обрабатываются данные в многопоточке,
мы с чистой душой, думая что всё настроили и дописали сервис отдаем его в нагрузочное тестирование,
рассказывая о том какая монго крутая, и что время ответа в 0.1ms она сама считает медленным...

И тут получаем статистику.
Которая идёт в разрез со всем, что мы видели.

Получаем данные профилирования и убеждаемся что тормозит исключительно MongoDB...

(тут картинки с деградацией)

Да, первое время на малом объёме данных монго работает великолепно, но по мере увеличения количества документов в ней
она деградирует в ответах, и начинает потреблять cpu за себя, да и за все остальные сервисы.
Пиковая нагрузка выдавала 10 из 12 ядер стенда в потолок, и ответ от 300мс до нескольких секунд
Вопрос стал на столько остро, что нам было сказано, если вы не найдёте ответ до конца спринта, мы отказываемся от монго в принципе.
И наша небольшая команда стала ломать голову, в чём же проблема.

Если честно, уже не вспомнить всех теорий заговора которые мы тогда придумывали, пытаясь понять что же происходит.
Я вспомнил, что в MS SQL сервере происходит деградация записи если довольно крупный кластерный индекс.
И тут нас всех озарило
По коллекции просто идёт фулскан. Оказывается MongoDB обычная база данных, и никакой магии не существует.
Хотя, пожалуй немного её было, стоило на лету создать индекс по полю фильтрации, на сервере моментально наступила тишина, и Mongo потребляла не более положеных для себя 50-70% cpu

_Вывод - не все так просто._

## 5 круг - Гнев и лень.  (live coding)

*Дима:*

- deploy: standalone => replica set => sharded cluster (yaml config) - почему 15 шт?
- mongod + mongos.
- Проверка отказоусточивости.
- рассказать про каталог Rollback

_Вывод - не все гладко, но дорогу осилит идущий._ 

(надо как-то переписать вывод, например что сильная сторона монги - легко поднимаемый кластер)


## 6 круг - Для еретиков и лжеучителей.

*Рома:*

- Решились сменить БД перед релизом во избежание сложных миграций.
Централизация использования технологий.
- Проблемы реляционного мышления при работе с noSQL(человеческий фактор).
Я сам .net разработчик с бэкграундом MS SQL SERVER и что я не понимал.
- collection != table. Хранение произвольных объектов в одной коллекции - добавить примеры (контрагенты - физлица и юрлица в одной коллекции).
- Сложный документ - значит транзакции частно не нужны - можно хранить все в одном документе.

(тут картинка - несколько таблиц превращаются в одну коллекцию)

_Вывод - надо заранее готовить аргументы и примеры для разработчиков._

## 7 круг - Для насильников и убийц всех мастей.

*Дима:*

- Измения в архитектуре и Переписываем реализацию старых(реляционных) репозиториев.
- Высокая трудоемкость при проектировании - plain-table перевести просто, остальное сложно и требуется переработка. 
- Ограничение на размер (16мб) и глубину документа (1000).
- Анализ индексов при проектирование и на бою под нагрузкой.

_Вывод - надо аккуратно проектировать._

## 8 круг - Для обманувших недоверившихся.

*Рома:*

Особенности при переходе на MongoDB.

- MongoShell. DSL. Начать изучение монги лучше отсюда. 
Рассказать про генераторы в js. Обратить внимание на перенос строк \n и ограниченную длину строки (не все документы помещаются)

(тут примеры js кода)

- Рассказать про nuget MongoDB.Driver, Core, Bson.
- Выделение отдельной сущности для singleton MongoClient - управление пулом коннектов и dispose автоматические.

(тут примеры кода)

- Непривычная фильтрация - вкусовщина, кому-то нравится, кому-то нет. Проблемы с лямбдами - найти issue.
    1. Условные операторы
    1. Логические операторы
    1. Поиск по массивам

(тут примеры кода)

- Сериализация. BSON документ (произвольные иерархические структуры данных) и простота сериализации. JObject отсутствует из коробки - сравнить в Newton.JSON и рассказать как писать свои сериализаторы. BsonIgnore и другие атрибуты, показать пример в коде. Конвенции.

(тут примеры кода)

- Транзакции - основы работы.
В июне 2018 года (в версии 4.0) добавлена поддержка транзакций, удовлетворяющих требованиям ACID.

```c#
var sessionOptions = new ClientSessionOptions
{
    DefaultTransactionOptions = new TransactionOptions(
        readConcern: new Optional<ReadConcern>(ReadConcern.Local),
        writeConcern: new Optional<WriteConcern>(WriteConcern.WMajority))
};
using var session = await _mongoConnectionManager.StartSession(sessionOptions);
session.StartTransaction(transactionOptions);
// var result = do some work with mongo db; 
if (result.Succeeded) await session.CommitTransactionAsync();
```

- Нет атрибутов для индексов, кроме BsonId. Рассказать про правила именования Id про ObjectId.
- Особенности использования индексов при построении запросов - один индекс на запрос (поискать hint в монго-клиенте).

_Вывод - сначала лучше попробовать вручную поработать через mongoshell._

## 9 круг - Для отступников и предателей всех сортов.

*Дима:*

- Проблемы с поиском по датам (фильтры, непонимание DSL) и Проблемы с UI для администрирования данных.

Неудобный MongoDB Compass. Есть DataGrip, Robo 3T.
Рассказать про средства мониторинга запросов, explain, план запроса.

- Проблема с транзакциями (работают только в режиме кластера). надо найти текст ошибок в монге и монго драйвере.

*Рома:*

Проблемы выявленные при тестировании:

- Проблемы сериализации GUID - добавить список.

```c#
BsonDefaults.GuidRepresentation = GuidRepresentation.Standard;
```

- Проблема версий пакета Mongo.Bson (DateTimeOffset) и необходимость интеграционных тестов на сериализацию/десериализацию.

_Вывод - BSON это гибкость, но сериализация требует особого внимания._

## Дорога к раю.

*Дима:*

Или почему MongoDB осталась основным хранилищем данных в проекте.

Производительность + нет миграций + отказоусточивость + стоимость.

## Q&A + Ссылки и контакты

MongoDB:
- https://en.wikipedia.org/wiki/MongoDB
- https://jira.mongodb.org/
- https://github.com/mongodb/
- https://docs.mongodb.com/

Доклад:

- https://github.com/daredever/MongoHell/
